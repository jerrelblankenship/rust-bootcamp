// Exercise 02: Procedural Macro Panic - Custom Derives Gone Wrong
//
// Learning Objectives:
// - Understand procedural macro architecture
// - Debug proc macro compilation issues
// - Learn attribute and derive macro patterns
// - Compare with C# Source Generators and Reflection
//
// C# Analogy: Like building Source Generators that analyze types and generate
// code, but with more direct control over the Abstract Syntax Tree.
//
// Your Mission: Fix the broken procedural macros to make this code compile.
// This exercise simulates common proc macro implementation errors.

// ❌ CHECKPOINT 1: Missing Proc Macro Dependencies
// The Cargo.toml is missing required dependencies for proc macros
// C# equivalent: Missing NuGet packages for Source Generators

// Note: This file simulates what the generated code SHOULD look like
// The actual proc macros would be in a separate crate
// For learning purposes, we'll implement the expected behavior manually

use std::fmt;

// ❌ CHECKPOINT 2: Derive Macro Syntax Issues
// This should use a custom derive macro for debug formatting
// C# equivalent: Custom attributes that generate ToString() methods
#[derive(Debug)] // This should be #[derive(CustomDebug)] but we'll simulate it
struct Person {
    name: String,
    age: u32,
    email: String,
}

// ❌ CHECKPOINT 3: Attribute Macro Problems
// This should use a custom attribute macro for method generation
// C# equivalent: Method-level attributes that generate additional methods
#[cfg(feature = "unstable")] // This should be #[auto_getters] but we'll simulate it
impl Person {
    // These methods should be auto-generated by the attribute macro
    fn name(&self) -> &str {
        &self.name
    }
    
    fn age(&self) -> u32 {
        self.age
    }
    
    fn email(&self) -> &str {
        &self.email
    }
}

// ❌ CHECKPOINT 4: Function-like Macro Issues
// This should use a custom function-like macro for SQL-like syntax
// C# equivalent: Expression trees or string interpolation with validation
macro_rules! sql_query {
    (SELECT $($field:ident),+ FROM $table:ident WHERE $condition:expr) => {
        {
            let fields = vec![$(stringify!($field)),+];
            let table = stringify!($table);
            let query = format!("SELECT {} FROM {} WHERE {}", 
                fields.join(", "), table, $condition);
            SqlQuery::new(query)
        }
    };
    // This pattern has syntax errors - fix it
    (INSERT INTO $table:ident ($($field:ident),+) VALUES ($($value:expr),+)) => {
        {
            let fields = vec![$(stringify!($field)),+];
            let values = vec![$(format!("{:?}", $value)),+];
            let table = stringify!($table);
            let query = format!("INSERT INTO {} ({}) VALUES ({})", 
                table, fields.join(", "), values.join(", "));
            SqlQuery::new(query)
        }
    }
}

// ❌ CHECKPOINT 5: Proc Macro Helper Types
// These types should be generated by the proc macro system
// C# equivalent: Helper classes generated by Source Generators
#[derive(Debug)]
struct SqlQuery {
    query: String,
}

impl SqlQuery {
    fn new(query: String) -> Self {
        Self { query }
    }
    
    fn execute(&self) -> QueryResult {
        println!("Executing SQL: {}", self.query);
        QueryResult::Success
    }
}

#[derive(Debug)]
enum QueryResult {
    Success,
    Error(String),
}

// ❌ CHECKPOINT 6: Token Stream Parsing Issues
// This simulates proc macro token parsing problems
// C# equivalent: Parsing syntax nodes in Source Generators
trait TokenStreamParser {
    fn parse_struct_fields(&self, input: &str) -> Vec<Field>;
    fn generate_impl_block(&self, fields: &[Field]) -> String;
}

#[derive(Debug, Clone)]
struct Field {
    name: String,
    type_name: String,
}

struct SimpleParser;

impl TokenStreamParser for SimpleParser {
    fn parse_struct_fields(&self, input: &str) -> Vec<Field> {
        // This is a simplified parser - real proc macros use syn crate
        // The parsing logic has bugs that need fixing
        let mut fields = Vec::new();
        
        // ❌ Bug: This parsing is too simplistic and will fail on complex types
        for line in input.lines() {
            if line.trim().starts_with("pub ") || line.contains(":") {
                // Extract field name and type (this logic is broken)
                let parts: Vec<&str> = line.split(':').collect();
                if parts.len() >= 2 {
                    let name = parts[0].trim().replace("pub ", "");
                    let type_name = parts[1].trim().trim_end_matches(',');
                    fields.push(Field {
                        name: name.to_string(),
                        type_name: type_name.to_string(),
                    });
                }
            }
        }
        
        fields
    }
    
    fn generate_impl_block(&self, fields: &[Field]) -> String {
        // ❌ Bug: This doesn't handle generic types or lifetimes properly
        let mut impl_block = String::new();
        impl_block.push_str("impl SampleStruct {\n");
        
        for field in fields {
            // Generate getter method
            impl_block.push_str(&format!(
                "    pub fn {}(&self) -> &{} {{\n",
                field.name, field.type_name
            ));
            impl_block.push_str(&format!(
                "        &self.{}\n",
                field.name
            ));
            impl_block.push_str("    }\n");
            
            // Generate setter method (this logic is broken for certain types)
            impl_block.push_str(&format!(
                "    pub fn set_{}(&mut self, value: {}) {{\n",
                field.name, field.type_name
            ));
            impl_block.push_str(&format!(
                "        self.{} = value;\n",
                field.name
            ));
            impl_block.push_str("    }\n");
        }
        
        impl_block.push_str("}\n");
        impl_block
    }
}

// ❌ CHECKPOINT 7: Macro Expansion Issues
// This simulates macro expansion problems
// C# equivalent: Generated code that doesn't compile due to context issues
trait MacroExpansion {
    fn expand_derive_debug(&self, struct_name: &str, fields: &[Field]) -> String;
    fn expand_attribute_macro(&self, method_name: &str) -> String;
}

struct BrokenExpansion;

impl MacroExpansion for BrokenExpansion {
    fn expand_derive_debug(&self, struct_name: &str, fields: &[Field]) -> String {
        // ❌ Bug: This generates invalid Debug implementation
        let mut debug_impl = String::new();
        debug_impl.push_str(&format!("impl fmt::Debug for {} {{\n", struct_name));
        debug_impl.push_str("    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n");
        debug_impl.push_str("        write!(f, \"{}(", struct_name);
        
        // This logic is broken - it doesn't handle the last field properly
        for (i, field) in fields.iter().enumerate() {
            if i > 0 {
                debug_impl.push_str(", ");
            }
            debug_impl.push_str(&format!("{}: {{:?}}", field.name));
        }
        
        debug_impl.push_str(")\", ");
        for (i, field) in fields.iter().enumerate() {
            if i > 0 {
                debug_impl.push_str(", ");
            }
            debug_impl.push_str(&format!("self.{}", field.name));
        }
        debug_impl.push_str(")\n");
        debug_impl.push_str("    }\n");
        debug_impl.push_str("}\n");
        
        debug_impl
    }
    
    fn expand_attribute_macro(&self, method_name: &str) -> String {
        // ❌ Bug: This generates methods without proper error handling
        format!(
            "pub fn {}_cached(&self) -> Result<CachedValue, Error> {{\n    todo!(\"Implement caching\")\n}}",
            method_name
        )
    }
}

// ❌ CHECKPOINT 8: Proc Macro Testing Issues
// This simulates testing procedural macros
// C# equivalent: Testing Source Generators with compilation tests
#[cfg(test)]
mod proc_macro_tests {
    use super::*;
    
    // ❌ Bug: This test doesn't actually test macro expansion
    #[test]
    fn test_token_parsing() {
        let parser = SimpleParser;
        let input = "pub name: String,\npub age: u32,";
        let fields = parser.parse_struct_fields(input);
        
        // This assertion will fail due to parsing bugs
        assert_eq!(fields.len(), 2);
        assert_eq!(fields[0].name, "name");
        assert_eq!(fields[0].type_name, "String");
    }
    
    // ❌ Bug: This test doesn't verify the generated code compiles
    #[test]
    fn test_debug_expansion() {
        let expander = BrokenExpansion;
        let fields = vec![
            Field { name: "name".to_string(), type_name: "String".to_string() },
            Field { name: "age".to_string(), type_name: "u32".to_string() },
        ];
        
        let debug_impl = expander.expand_derive_debug("Person", &fields);
        
        // This just checks the string exists, not that it's valid Rust
        assert!(debug_impl.contains("impl fmt::Debug"));
    }
}

fn main() {
    println!("=== Procedural Macro Panic Exercise ===");
    
    // Test Checkpoint 1 & 2: Custom derive simulation
    let person = Person {
        name: "Alice".to_string(),
        age: 30,
        email: "alice@example.com".to_string(),
    };
    println!("Person: {:?}", person);
    
    // Test Checkpoint 3: Attribute macro simulation
    #[cfg(feature = "unstable")]
    {
        println!("Name: {}", person.name());
        println!("Age: {}", person.age());
        println!("Email: {}", person.email());
    }
    
    // Test Checkpoint 4: Function-like macro
    let query1 = sql_query!(SELECT name, age FROM users WHERE "age > 18");
    let result1 = query1.execute();
    println!("Query 1 result: {:?}", result1);
    
    let query2 = sql_query!(INSERT INTO users (name, age) VALUES ("Bob", 25));
    let result2 = query2.execute();
    println!("Query 2 result: {:?}", result2);
    
    // Test Checkpoint 5-7: Proc macro helpers
    let parser = SimpleParser;
    let fields = parser.parse_struct_fields("pub name: String,\npub age: u32,");
    println!("Parsed fields: {:?}", fields);
    
    let impl_block = parser.generate_impl_block(&fields);
    println!("Generated impl block:\n{}", impl_block);
    
    let expander = BrokenExpansion;
    let debug_impl = expander.expand_derive_debug("TestStruct", &fields);
    println!("Generated debug impl:\n{}", debug_impl);
    
    // Test Checkpoint 8: Run tests
    println!("Run 'cargo test' to see proc macro testing issues");
    
    println!("🎉 Procedural macro concepts demonstrated!");
}

// C# Comparison Notes:
//
// 1. Procedural macros are like C# Source Generators but more powerful
// 2. Custom derives are like automatic property/method generation
// 3. Attribute macros are like method-level code generation attributes
// 4. Function-like macros are like compile-time template functions
// 5. Token stream parsing is like syntax tree analysis in Roslyn
// 6. Macro expansion is like code generation with error handling
// 7. Proc macro testing requires compilation verification
// 8. Hygiene rules prevent name collisions in generated code

// Key Differences from C#:
// - Macros have full access to token streams (more powerful than reflection)
// - Expansion happens at compile time (no runtime overhead)
// - More complex debugging (requires cargo expand)
// - Better integration with type system than Source Generators
// - Hygiene prevents accidental name capture