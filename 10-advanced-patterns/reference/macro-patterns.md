# Macro Patterns: From C# Code Generation to Rust Macros

## üéØ Overview

Rust's macro system provides compile-time code generation capabilities that far exceed what's available in C#. While C# has Source Generators and preprocessor directives, Rust macros work directly with the language's syntax and can create entirely new syntactic constructs.

## üîÑ C# vs Rust Comparison

### Code Generation Approaches

| Aspect | C# Source Generators | Rust Declarative Macros | Rust Procedural Macros |
|--------|---------------------|------------------------|------------------------|
| **Input** | Syntax trees | Token patterns | Token streams |
| **Output** | Additional files | Token replacement | Token streams |
| **Execution** | Compilation phase | Macro expansion | Compilation phase |
| **Debugging** | Source stepping | `cargo expand` | `cargo expand` |
| **Power** | Type analysis | Pattern matching | Full AST access |

## üìù Declarative Macros

### Basic Pattern Matching

**C# Equivalent**: Preprocessor macros (but much more powerful)

```rust
// Rust declarative macro
macro_rules! create_getter {
    ($field:ident, $type:ty) => {
        pub fn $field(&self) -> &$type {
            &self.$field
        }
    };
}

// Usage
struct Person {
    name: String,
    age: u32,
}

impl Person {
    create_getter!(name, String);
    create_getter!(age, u32);
}
```

**C# Equivalent**:
```csharp
// C# would require Source Generator
[GenerateGetter("Name")]
[GenerateGetter("Age")]
public partial class Person
{
    private string name;
    private int age;
    
    // Generated by Source Generator:
    // public string Name => name;
    // public int Age => age;
}
```

### Repetition Patterns

**C# Equivalent**: Template expansion in T4 or Source Generators

```rust
// Rust: Multiple field handling
macro_rules! create_struct {
    ($name:ident { $($field:ident: $type:ty),* }) => {
        struct $name {
            $($field: $type),*
        }
        
        impl $name {
            fn new($($field: $type),*) -> Self {
                Self { $($field),* }
            }
        }
    };
}

// Usage
create_struct!(User {
    id: u64,
    email: String,
    active: bool
});
```

**C# Equivalent**:
```csharp
// C# Source Generator would analyze attributes
[GenerateStruct]
public partial class User
{
    [Field] public ulong Id;
    [Field] public string Email;
    [Field] public bool Active;
    
    // Generated constructor:
    // public User(ulong id, string email, bool active) { ... }
}
```

### Complex Pattern Matching

```rust
// Rust: SQL-like DSL
macro_rules! sql {
    (SELECT $($field:ident),+ FROM $table:ident WHERE $condition:expr) => {
        {
            let fields = vec![$(stringify!($field)),+];
            let table = stringify!($table);
            format!("SELECT {} FROM {} WHERE {}", 
                   fields.join(", "), table, $condition)
        }
    };
    
    (INSERT INTO $table:ident ($($field:ident),+) VALUES ($($value:expr),+)) => {
        {
            let table = stringify!($table);
            let fields = vec![$(stringify!($field)),+];
            let values = vec![$(format!("{:?}", $value)),+];
            format!("INSERT INTO {} ({}) VALUES ({})",
                   table, fields.join(", "), values.join(", "))
        }
    };
}

// Usage
let query1 = sql!(SELECT id, name FROM users WHERE "active = true");
let query2 = sql!(INSERT INTO users (name, email) VALUES ("Alice", "alice@example.com"));
```

**C# Equivalent**:
```csharp
// C# would need expression trees or string interpolation
public static class SqlBuilder
{
    public static string Select<T>(Expression<Func<T, object>> fields, 
                                  string table, string condition)
    {
        // Complex reflection-based implementation
        // Less type-safe and more runtime overhead
    }
}
```

## ‚öôÔ∏è Procedural Macros

### Derive Macros

**C# Equivalent**: Source Generators with attribute analysis

```rust
// Rust procedural macro
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput};

#[proc_macro_derive(Builder)]
pub fn derive_builder(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = input.ident;
    let builder_name = format_ident!("{}Builder", name);
    
    // Generate builder pattern code
    let expanded = quote! {
        impl #name {
            pub fn builder() -> #builder_name {
                #builder_name::default()
            }
        }
        
        #[derive(Default)]
        pub struct #builder_name {
            // Builder fields...
        }
        
        impl #builder_name {
            // Builder methods...
        }
    };
    
    TokenStream::from(expanded)
}
```

**C# Equivalent**:
```csharp
// C# Source Generator
[Generator]
public class BuilderGenerator : ISourceGenerator
{
    public void Execute(GeneratorExecutionContext context)
    {
        // Analyze syntax trees
        // Generate builder classes
        // Add to compilation
    }
    
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }
}
```

### Attribute Macros

**C# Equivalent**: Aspect-oriented programming or interceptors

```rust
// Rust attribute macro
#[proc_macro_attribute]
pub fn cache(args: TokenStream, input: TokenStream) -> TokenStream {
    let input_fn = parse_macro_input!(input as ItemFn);
    let fn_name = &input_fn.sig.ident;
    
    let expanded = quote! {
        thread_local! {
            static CACHE: RefCell<HashMap<String, String>> = 
                RefCell::new(HashMap::new());
        }
        
        #input_fn
        
        pub fn #fn_name_cached(input: &str) -> String {
            CACHE.with(|cache| {
                if let Some(cached) = cache.borrow().get(input) {
                    return cached.clone();
                }
                
                let result = #fn_name(input);
                cache.borrow_mut().insert(input.to_string(), result.clone());
                result
            })
        }
    };
    
    TokenStream::from(expanded)
}
```

**C# Equivalent**:
```csharp
// C# interceptor or proxy pattern
[Cache]
public string ExpensiveOperation(string input)
{
    // Original implementation
}

// Generated or intercepted at runtime:
public string ExpensiveOperationCached(string input)
{
    if (cache.TryGetValue(input, out var cached))
        return cached;
        
    var result = ExpensiveOperation(input);
    cache[input] = result;
    return result;
}
```

## üéØ When to Use Each Pattern

### Declarative Macros

**Use When**:
- Creating DSLs (Domain-Specific Languages)
- Reducing repetitive code patterns
- Compile-time string processing
- Simple code generation

**C# Alternative**: Source Generators for complex cases, preprocessor for simple ones

### Procedural Macros

**Use When**:
- Complex derive implementations
- Attribute-based code generation
- Function transformation
- Custom syntax extensions

**C# Alternative**: Source Generators, Roslyn analyzers

## üîß Advanced Patterns

### Macro Hygiene

**Rust Advantage**: Automatic variable scoping prevents name collisions

```rust
macro_rules! safe_increment {
    ($var:ident) => {
        {
            let temp = $var;  // 'temp' is hygienic
            $var = temp + 1;
        }
    };
}

// Usage - 'temp' won't conflict with user variables
let temp = 5;
safe_increment!(temp);  // Works correctly
```

**C# Challenge**: Source Generators need careful namespace management

### Recursive Macros

```rust
// Rust: Count macro arguments
macro_rules! count {
    () => (0);
    ($head:expr) => (1);
    ($head:expr, $($tail:expr),*) => (1 + count!($($tail),*));
}

let count = count!(a, b, c, d);  // Results in 4
```

**C# Equivalent**: Would require compile-time recursion in Source Generators

### Proc Macro Testing

```rust
// Rust: Testing macro expansion
#[test]
fn test_builder_macro() {
    let t = trybuild::TestCases::new();
    t.pass("tests/01-parse.rs");
    t.compile_fail("tests/02-create-builder.rs");
}
```

**C# Equivalent**: Testing Source Generators requires compilation verification

## üöÄ Best Practices

### Declarative Macros

1. **Keep patterns simple** - Complex patterns are hard to debug
2. **Use descriptive names** - Fragment specifiers should be clear
3. **Handle edge cases** - Empty repetitions, optional elements
4. **Document expansion** - Show what the macro generates

### Procedural Macros

1. **Validate input** - Check for correct syntax early
2. **Generate readable code** - Use `cargo expand` to verify
3. **Handle errors gracefully** - Provide helpful error messages
4. **Test thoroughly** - Include positive and negative test cases

## üí° C# Developer Tips

1. **Think compile-time**: Macros run during compilation, not runtime
2. **Embrace pattern matching**: More powerful than C# string manipulation
3. **Use `cargo expand`**: Like viewing generated C# code
4. **Start simple**: Begin with basic patterns before complex ones
5. **Leverage existing crates**: `syn`, `quote`, `proc-macro2` for proc macros

## üîç Debugging Techniques

### Macro Expansion

```bash
# View expanded macros
cargo expand

# Specific function
cargo expand ::module::function_name

# With features
cargo expand --features="macro-debugging"
```

**C# Equivalent**: Viewing generated Source Generator output in IDE

### Error Messages

```rust
// Rust: Custom error messages in proc macros
return syn::Error::new(
    input.span(),
    "Builder can only be derived for structs"
).to_compile_error().into();
```

**C# Equivalent**: Diagnostic reporting in Source Generators

This macro system enables Rust to have extremely flexible syntax while maintaining zero runtime cost - something that's much harder to achieve in C# due to its runtime-oriented design.